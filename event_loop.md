---
title: Концепция Event Loop в языке JavaScript
description: Основы механизма Event Loop в языке программирования JavaScript
image: "https://hsto.org/r/w1560/getpro/habr/upload_files/a05/8ff/096/a058ff096a74d751145897753515fb0c.png"
author: Ринат Камалитдинов
---

Цикл событий (event loop) — это ключ к асинхронному программированию на JavaScript. Сам по себе JavaScript однопоточный, но использование механизма event loop позволяет создать дополнительные потоки, чтобы код работал быстрее. В этом гайде мы разберемся, что такое стек вызовов и как он связан с циклом событий.

Чтобы выполнить код, нам нужен JavaScript Engine (движок) — программа, которая «читает и выполняет» то, что мы написали. Самый распространенный движок среди всех — это V8, он используется в Google Chrome и Node.js.

Выполнение JS-кода — однопоточное. Это значит, что в конкретный момент времени движок может выполнять не более одной строки кода. То есть вторая строка не будет выполнена, пока не выполнится первая. Такое выполнение кода (строка за строкой) называется синхронным.

Но работа в браузере не всегда может быть обеспечена синхронным кодом, который выполняет операции строго последовательно. То, что происходит в программе (при работе в браузере) определяется не самой программой, а событиями, которые обрабатываются этой программой. Такой принцип работы программы называется событийной моделью.

Скрипт в браузере находится в постоянном режиме ожидания: как только происходит какое-либо событие (а разных событий бывает очень много - клик, скролл, свайп и т.д.) - программа начинает выполнять различные операции (например, расчет страховки, поиск авиабилетов, чтение документов…), после чего снова ожидает наступления новых событий. 

## Стек вызовов

Когда произошло определенное событие, вызвавшее функцию в JavaScript, такая функция она попадает в так называемый стек вызовов. 

**[Стек](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA)** — это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым (LIFO: last in, first out). Стек похож на стопку книг: та книга, которую мы кладем последней, находится сверху.
В стеке вызовов хранятся функции, до которых дошел интерпретатор, и которые надо выполнить.

Рассмотрим пример работы асинхронного кода.

```js
const main = () => {
  setTimeout(function greet() {
    console.log('Hello!');
  }, 2000);

  console.log('Bye!');
};

main()
```

Вызываем функцию `main()`. Стек:

```js
main();
```

Вызываем `setTimeout()`. Стек:

```js
setTimeout();
main();
```

`setTimeout` завершился, он выходит из стека:

```js
main();
```

Вызываем `console.log('Bye!')`:

```js
console.log('Bye!');
main();
```

Его вызов завершён, он выходит из стека:

```js
main();
```

Вызов `main()` тоже завершён, стек становится пуст.

Проходит около 2 секунд, вызывается функция `greet()`, она попадает в стек:

```js
greet();
```

Она вызывает `console.log('Hello!')`:

```js
console.log('Hello!');
greet();
```

Отработав, она уходит из стека:

```js
greet();
```

После выполнения всего блока стек снова становится пустым.

## Web API и Event Loop

Важную роль в браузере выполняет **Web API**. Это дополнительная функциональность браузера, которая берёт на себя работу с таймерами, интервалами, обработчиками событий. То есть когда мы регистрируем обработчик клика на кнопку — он попадает в окружение Web API. Именно оно знает, когда обработчик нужно вызвать.

Управление тем, как должны вызываться функции Web API, берёт на себя _цикл событий_ (Event loop).

**[Цикл событий](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#Цикл*событий)** отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.

Именно цикл событий ответственен за то, что `setTimeout()` пропал из стека в прошлом примере. Чтобы увидеть картину целиком, давайте включим в нашу схему все недостающие части. Возьмём тот же самый пример:

```js
const main = () => {
  setTimeout(function greet() {
    console.log('Hello!');
  }, 2000);

  console.log('Bye!');
};

main()
```

Но теперь у нас будет не только стек вызовов — также мы включим Web API и очередь задач, которую Web API использует для хранения того, что нужно выполнить.

Вызов `main()`:

| Стек     | Web API | Очередь задач |
|----------| ------- | ------------- |
| `main()` |         |               |

В Web API и очереди задач пока пусто.

Вызов `setTimeout()`:

| Стек           | Web API | Очередь задач |
|----------------| ------- | ------------- |
| `setTimeout()` |         |               |
| `main()`       |         |               |

Когда `setTimeout()` исчезает из стека, он попадает в видимость Web API, где интерпретатор понимает, что внутри него есть функция `greet()`, которую надо выполнить через 2 секунды:

| Стек     | Web API             | Очередь задач |
|----------| ------------------- | ------------- |
| `main()` | `setTimeout(greet)` |               |

После этого выполняется вызов консоли `console.log('Bye!')`. В Web API находится функция `setTimeout(greet)`. Она будет там до тех пор, пока не пройдёт 2 секунды:

| Стек                 | Web API             | Очередь задач |
|----------------------| ------------------- | ------------- |
| `console.log('Bye!')` | `setTimeout(greet)` |               |
| `main()`             |                     |               |

Отработал `console.log()`, заканчивается работа `main()`:

| Стек     | Web API             | Очередь задач |
|----------| ------------------- | ------------- |
| `main()` | `setTimeout(greet)` |               |

`main()` отработал, стек пуст. 2 секунды ещё не прошло, поэтому `setTimeout(greet)` все ещё в Web API:

| Стек         | Web API             | Очередь задач |
| ------------ | ------------------- | ------------- |
|              | `setTimeout(greet)` |               |

Наконец, 2 секунды прошли - функция `greet()` перемещается в очередь задач:

| Стек         | Web API | Очередь задач |
| ------------ | ------- |---------------|
|              |         | `greet()`     |

Теперь цикл событий перемещает функцию `greet()` из списка задач в вызов:

| Стек      | Web API | Очередь задач |
|-----------| ------- | ------------- |
| `greet()` |         |               |

Затем вызов `console.log('Hello!')`:

| Стек                    | Web API | Очередь задач |
|-------------------------| ------- | ------------- |
| `console.log('Hello!')` |         |               |
| `greet()`               |         |               |

И, наконец, стек пуст.

Заметьте, что стек вызовов и очередь задач называются именно стеком и очередью. Потому что вызовы из стека работают по принципу _«последний зашёл, первый вышел»_ (LIFO: last in, first out), а в очереди — по принципу _«первый зашёл, первый вышел»_ (FIFO: first in, first out).

## Дополнительно

Очень хорошо работу цикла событий иллюстрирует **[инструмент Loupe](http://latentflip.com/loupe/)** Филиппа Робертса, а также его доклад **[«What the heck is the event loop anyway?»](https://www.youtube.com/watch?v=8aGhZQkoFbQ)** на европейской конференции JSConf в 2014 году.

Loupe интерактивный - попробуйте ввести какой-нибудь код в поле слева, и справа будет показываться, что и в какой момент попадает в стек вызовов и очередь событий:

![Визуализатор Loupe](https://user-images.githubusercontent.com/64750426/205178536-c17a0a19-5b51-48dc-9944-b4665ce80d2e.jpg)

Кроме того, рекомендуем ознакомиться с описанием Event Loop в **[официальной документации](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)** на MDN Web Docs.   

## Выводы

Встроенный механизм Event Loop помогает JavaScript обрабатывать асинхронный код. Понимание этого механизма позволяет разработчикам писать более эффективный код, который работает быстро и не блокирует выполнение другого кода.
